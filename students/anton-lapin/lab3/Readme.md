* SVM: Метод Опорных Векторов - Практическая реализация

Информация о датасете
Для демонстрации работы SVM используется синтетический датасет make_circles:
Только 2 фичи: X и Y координаты
Только числовые данные: нет категориальных переменных
Нет пропусков: данные полные и готовы к использованию
Уже масштабированы: примерно в диапазоне [-1.5, 1.5]
Структура данных:
Классы представляют собой 2 круга: один большего радиуса, другой меньшего
factor - во сколько раз один радиус больше другого
n_samples - количество примеров (по умолчанию 1000)
noise - уровень шума в данных

Датасет очень простой и идеально подходит для учебной задачи, поскольку позволяет наглядно продемонстрировать разницу между линейными и нелинейными классификаторами.

Баланс классов
https://images/%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2.png

Распределение классов в тренировочной и тестовой выборках. Как видно, классы сбалансированы - это важное условие для корректной работы SVM.

Сравнение ядер SVM
https://images/%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%8F%D0%B4%D0%B5%D1%80.png

На этом графике показано сравнение различных ядер SVM:

Линейное ядро - строит только прямые границы
RBF ядро - может строить сложные нелинейные границы
Линейное ядро (scikit-learn)
https://images/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%BE%D0%B5_%D1%8F%D0%B4%D1%80%D0%BE_sklearn.png

Линейный SVM пытается разделить круги прямой линией, что невозможно для данной задачи. Это демонстрирует ограниченность линейных классификаторов для нелинейно разделимых данных.
RBF ядро (scikit-learn)
https://images/RBF_%D1%8F%D0%B4%D1%80%D0%BE_sklearn.png

RBF SVM успешно разделяет круги, строя сложную нелинейную границу. Это достигается за счет преобразования данных в пространство более высокой размерности.

Наша реализация RBF ядра
https://images/RBF_%D1%8F%D0%B4%D1%80%D0%BE_%D0%BB%D0%B8%D1%87%D0%BD%D0%BE%D0%B5.png

Наша собственная реализация RBF SVM показывает результаты, сравнимые с scikit-learn. Граница решения правильно разделяет два круга, что подтверждает корректность нашей реализации.

Ключевые особенности реализации
Математическая основа
Двойственная задача SVM: Реализовано решение через множители Лагранжа

Условия ККТ: Полное соблюдение условий Каруша-Куна-Таккера

RBF ядро: Собственная реализация без использования sklearn

Технические детали
Полная векторная реализация на NumPy

Использование scipy.optimize для решения задачи квадратичного программирования

Поддержка параметров C и gamma как в scikit-learn

Визуализация границ решения и опорных векторов

Сравнение с scikit-learn
Проект включает подробное сравнение с sklearn.svm.SVC:

Точность классификации

Количество опорных векторов

Время обучения

Качество границ решения
